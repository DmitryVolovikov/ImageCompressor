# **ImageCompressor**

[Актуальная изменяемая версия задания](https://buildin.ai/dfbakin/share/6d841f34-7ec5-489f-9d48-46293045f76b?code=KHTJB8)

# Суть проекта

Вы разработаете систему, которая будет предоставлять следующие возможности:

- чтение, запись несжатого изображения в собственном формате файла (далее `UncompressedImage`)

- чтение, запись сжатого изображения в собственном формате файла (далее `CompressedImage`)

- чтение изображений формата BMP в `UncompressedImage`, запись `UncompressedImage` в формате BMP на диск (библиотека для работы с BMP предоставляется)

- Отражение, поворот, негатив и преобразование в черно-белую палитру для изображений

- Применение произвольного фильтра ядра изображения (kernel filters)

- Повышение контрастности, размытие, выделение краев с помошью kernel filters

По мере корректной реализации функций и структур проекта ваш код проходить больше тестов, каждый из которых проверяет какой-то конкретный функционал. За каждый пройденный тест начисляет указанное количество баллов. Чтобы понять, какой функционал и как нужно реализовать, необходимо думать самостоятельно и внимательно читать код тестов.

Для проверки и фиксации баллов нужно сдать решения в яндекс контест. Все решения будут проверены на плагиат.



# Настройка среды

Консольные команды и инструкции указаны для операционной системы Linux. В MacOS 95% команд будут работать так же, разве что кроме названия утилиты установки (не `apt`) -- посмотрите в интернете. Если вы используете Linux, то нужно установить WSL.

- Для пользователей Windows (установка WSL)

    Необходимо установить WSL2:

    1. устанавливаем WSL2 (выполняем PowerShell с правами администратора `wsl --install`)

    2. устанавливаем Ubuntu 22.04 LTS или Ubuntu 24.04 LTS из Microsoft store

    3. откройте открывшееся приложение (Ubuntu или Linux, или WSL) и создайте пользователя, если там просят. После этого проверьте, что перед вами функционирующая Linux консоль

    4. устанавливаем в VS Code расширение "Remote Development" от автора microsoft.com, оно должно состоять из 4 модулей, один из которых называется WSL

    5. комбинация Ctrl + Shift + P   вызовет панель команд, в которой нужно начать вводить WSL и выбрать Connect to WSL

    6. после успешного подключения можно работать: 

        7. слева проводник файлов вашей подсистемы

        8. внизу -- консоль, в которую вы будете вводить команды

        9. создавать, удалять, использовать, открывать и редактировать файлы можно как при обыкновенной работе в VS Code

    10. Установите расширения для удобной работы в VS Code: C++ Extension Pack, Clang Format, 

    11. Вы успешно установили подсистему Linux и можете в ней запускать, собирать и разрабатывать проект

    12. Файлы при некотором желании можно найти в сетевой папке в обыкновенно Проводнике (Explorer)

Альтернатива для пользователей Windows -- ([установка docker](https://ubuntu.com/tutorials/windows-ubuntu-hyperv-containers#1-overview)). Затем подключаемся к нему и так же работаем через VS Code



Чтоб открыть консоль, нужно использовать комбинацию клавиш `Ctrl + Shift + ``

## Устанавливаем зависимости

```Shell
sudo apt update
sudo apt install -y build-essential make clang-format git
```

---

## Скачиваем проект

Методы далее перечислены в порядке убывания сложности и "правильности" с точки зрения разработки

[Ссылка задания на GitHub](https://github.com/dfbakin/ImageCompressorBlank)



### Использование git и ссылки на оригинал проекта

- Регистрируемся на [github.com](https://github.com)

- Создаем ПУСТОЙ ПРИВАТНЫЙ репозиторий (СНИМАЕМ все галочки с "создать" что угодно и НЕ ВЫБИРАЕМ лицензию). Название -- любое подходящее, например, ImageCompressor

- открываем любую папку в  VS Code, в которой вы хотите создать папку проекта. В терминале VS Code ( Ctrl + Shift + ` ) в этой папке выполняем

```Shell
git clone <YOUR_LINK_TO_REPO> # ссылка на ВАШ СОЗДАННЫЙ репозиторий
ls # выводим все, что есть в текущей директории
cd ImageCompressor # переходим в созданную папку
git remote add upstream <TASK_LINK_TO_REPO> # ссылка на ИСХОДНЫЙ репозиторий
git checkout -b master
git pull upstream master

```

Должно появиться много файлов

- Для тех, кто хочет работать с VCS (необязательно)

    Тогда стоит прочитать подробнее о системе контроля версий самостоятельно

    Если вы молоды, энергичны и уверены в себе, то [привыкайте использовать SSH](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent) для доступа к аккаунтам и репозиториям. [Добавлять сюда](https://github.com/settings/keys)

    Настройка учетной записи

    ```Shell
    git config --global user.name "YOU"
    ```

    В VS Code слева можно выбрать те измененные и созданные файлы, которые вы хотите зафиксировать коммитом. Альтернативно можно то же сделать командой `git add`

    ```Shell
    git commit -m "your_message"
    git push origin master # либо любая ваша текущая ветка
    ```

Чтобы "пратащить" к себе изменения задания, которые могут происходить, нужно:

- созхранить любым способ ваши изменения файлов

- изменить исходные файлы

- применить все ваши изменения

Это можно сделать следующими способами:

```Shell
git stash # сохраняем изменения
git pull upstream master # обновится именно master ветка
git stash pop # снова применяем изменения
```

или

```Shell
git pull --rebase upstream master # обновится именно master ветка
```

При возникновении конфликтов их нужно будет решить вручную. VS Code предоставляет красивый интерфейс для этого в панели слева



### Использование git без привязки к оригиналу

- Регистрируемся на [github.com](https://github.com)

- открываем любую папку в  VS Code, в которой вы хотите создать папку проекта. В терминале VS Code ( Ctrl + Shift + ` ) в этой папке выполняем

```Shell
git clone <TASK_LINK_TO_REPO> # ссылка на исходный репозиторий
ls # выводим все, что есть в текущей директории
cd ImageCompressor # переходим в созданную папку
```

Здесь много файлов. Созданную папку можно открыть в VS Code с помощью ( Ctrl + K, O )



### Скачивание архива с диска

[Ссылка](https://disk.yandex.ru/d/EV9t2od2raiSlQ) ведет на архив проекта, который будет иногда(!) обновляться. Могут появляться тесты, новые изображения, исправляться задания и сигнатуры функций, тесты. О важных изменениях могут быть сообщения в канале



## Выставляем компилятор

Далее вам нужно определить, каким компилятором вы хотите пользоваться и написать его в начале `Makefile`. Если `g++`, то можно не менять (он уже проставлен). Если `clang++`, то нужно заменить `g++` на `clang++` в строке:

```MakeFile
CXX := g++
```



## Проверяем

Из корня проекта выполняем в консоли `make run`, видим успешную сборку и `Hello, World!`

Из корня проекта выполняем в консоли `make test`, видим успешную сборку, сообщения о провале тестов и выставленные 0 баллов



# Сборка проекта и запуск тестов

В качестве системы сборки (громко сказано) используется утилита make, которая выполняет `Makefile`

- `make build` — соберет все файлы

- `make clean` — очистит файлы сборки и временные файлы

- `make test` — соберет и запустит тесты БЕЗ вашего main.cpp

- `make run` — соберет файлы проект БЕЗ тестов и запустит проект С вашим main.cpp

- `make clean test` — соберет проект с тестами **заново**, то есть после очистки

Для стабильного запуска тестов можно вызывать `make build run`



Предупреждения компилятора воспринимаются как ошибки компиляции -- их допускать нельзя. В контесте, который засчитывает вам баллы будет настроены та же система. Будьте внимательны!





# Структура проекта

Здесь стоит подробнее поговорить о структуре проекта на языке C++. Самое главное и самое важное -- теперь можно писать код не только в `main.cpp` и даже не только в файлах `.cpp`, а еще и в `.h` файлах, которых называются хэдер (header) файлами или заголовочными файлами.

## Заголовочные файлы

Хэдер файлы содержат *объявления* функций, классов, структур и глобальных переменных и предназначены для того, что написанные вами объекты можно было использовать в других файлах. Например, когда вы пишете `#include <iostream>`в начале вашего файла, перед компиляцией препроцессор (часть компилятора) подставит вместо вашего `#include` целый заголовочный файл `iostream`, в котором, например, содержатся объявления таких функция как prinf, scanf, таких классов как std::basic_iostream и известных вам объектов `std::ostream cout`, `std::istream cin`. В заголовочном файле эти объекты были объявлены и созданы, но *не реализованы*

Дело в том, что для *реализации* функций, классов, методов используют source файлы -- расширение `.cpp`.

Например, вот вот так бы работала программа, которая считывает точки в вектор, сортирует его и выводит.

```C++
#include <cstdint>
#include <vector>

struct Point {
    int64_t x = 0;
    int64_t y = 0;
    int64_t z = 0;
};

void inputPoints(size_t n, std::vector<Point>& points);

void solve();
```

```C++
#include <iostream>

#include "point_utils.h"

void inputPoints(size_t n, std::vector<Point>& points) {
    points.resize(n);
    for (size_t i = 0; i < n; ++i) {
        std::cin >> points[i].x >> points[i].y >> points[i].z;
    }
 }

void solve() {
    size_t num;
    std::cin >> num;
    std::vector<Point> points;
    inputPoints(n, points);
    std::cout << "Entered " << n << " points\n";
}
```

Здесь важно обратить внимание на `#include` в файлах. В каждом из файлов нужно подключать именно то, что в нем используется: не больше и не меньше. Так получается, что `<include>`подключен только с `point_utils.cpp`. Также в этом файле подключен весь хэдер с объявлениями `point_utils.h`, значит, в нашем`.cpp`объявлены все функции, структуры и подключены все хэдеры из `point_utils.h`: например, `<vector>`был подключен лишь один раз.

Чтобы скомпилировать такую программу нужно использовать консольную команду для компилятора, которая будет выглядеть следующим образом:

`g++ -I<include_directory> <source_file_1> <source_file_2> -o <output_executable>`

Для файлов в примере: `g++ -Iinclude point_utils.cpp -o main` -- соберет программу в исполняемый файл `main`, который можно запустить консольной командой `./main`

## Директории проекта

- `include` содержит в себе заголовочные файлы

- `src` от англ. source -- содержит в себе `.cpp`файлы. Как правило, они имею одноименные (или как минимум соответствующие заголовочные файлы из `include`)

- `images`-- директория с BMP изображениями, которые используются в тестах





# Примеры работы с BMP библиотекой

Конкретное поведений можно понять:

- из примеров ниже по кода

- из примеров ниже, написав их в `main.cpp` и запустив их с помощью `make run`

- прочитав и поняв суть кода файлов `libbmp.h` и `libbmp.cpp`

- обязательно смотрите на сигнатуры функций библиотеки в файле`libbmp.h`

```C++
// create BMP file

BMP bmp(2, 2);
bmp.set_pixel(0, 0, 255, 0, 0);
bmp.set_pixel(1, 0, 255, 255, 0);
bmp.set_pixel(0, 1, 255, 0, 255);
bmp.set_pixel(1, 1, 0, 255, 0);
const std::string filename = "image.bmp";
bmp.write(filename.c_str());
```

```C++
// load BMP file
const std::string filename = "image.bmp";
BMP bmp(filename.c_str());
bmp.get_width();
bmp.get_height();
uint8_t r, g, b;
bmp.get_pixel(0, 0, r, g, b);
// now r, g, b contain color channels values from RGB pixel at (0; 0)
```

# Форматы файлов изображений

Для записи на диск и чтения с него изображений `UncompressedImage` и `CompressedImage` используются следующие двоичные файлы со следующей структурой и размером:

```Plain Text
====RAW FILE FORMAT====
- 10 byte: file format string. Must equal to "RAWIMAGE" without quotes
- 3 byte: format version. Must be equal to 1, 0, 0 respectively
- 4 byte: width
- 4 byte: height
- 1 byte: grayscale
IF GRAYSCALE == 1
- width * height byte: grayscale pixels
ELSE
- width * height * 3 byte: RGB pixels
end signature: 10 byte. Must equal to "RAWIMGEND" without quotes


====COMPRESSED FILE FORMAT====
- 10 byte: file format string. Must equal to "CMPRIMAGE" without quotes
- 3 byte: format version. Must be equal to 6, 6, 6 respectively
- 4 byte: width
- 4 byte: height
- 1 byte: pow of colortable size
- 2^pow * 3 byte: RGB colortable
- width * height byte: ids of colors from colortable
end signature: 10 byte. Must equal to "CMPRIMGEND" without quotes
```

